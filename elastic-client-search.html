<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../dig-common/dig-common.html">

<!--

        Element which provides a view of an Elasticsearch index, and coordinates
        building and issuing queries using the elastic.js library.  Satellite
        elements for query, filters, aggregation, sorting, and paging communicate
        with this element to make changes to the index object, and to receive
        results from queries that are issued to an elastic server instance.

        If given a body object as input, this element makes AJAX request to
        elasticsearch REST API.

        Example:

        <elastic-client
            config='{"host": "http://localhost:9200"}'
            client="{{esclient}}"
            cluster-status="{{my-status}}">
        </elastic-client>

        <elastic-client-search
            client="[[esclient]]"
            index="ads"
            elastic-types='["offer", "seller"]'
            body='{"query": {"match_all": {}}}'
            results="{{data}}"
            lastError="{{error}}">
        </elastic-client-search>

@demo demo/index.html

-->
<script>
    Polymer({
        /* globals _, ejs*/
        is: 'elastic-client-search',

        properties: {
            /**
             * an instance of elasticsearch.Client which is connected to
             * an elasticsearch server
             */
            client: {
                type: Object
            },

            /**
             * the elastic index (database name)
             */
            index: {
                type: String
            },

            /**
             * the elastic type (optional -- leave empty for all types)
             */
            elasticTypes: {
                type: Array,
                value: []
            },

            /**
             * a fully specified elastic query.  Use this if you do not want
             * the query body to be built by this element.
             * (see https://www.elastic.co for search API)
             *
             * I body is non-null, then the basicSearch observer will be invoked.
             *
             */
            body: {
                type: Object,
                notify: true
            },

            /**
             * The elasticsearch query that should be invoked.
             */
            query: {
                type: Object,
                notify: true,
                observer: '_resetPage'
            },

            /**
             * an ejs.Sort() object to add to the request
             */
            sort: {
                type: Object,
                value: function() {
                    return {};
                },
                notify: true
            },

            /**
             * The field on which to sort.  Must also define sortOrder.  Overridden by defining sort.
             */
            sortField: {
                type: String,
                value: ''
            },

            /**
             * The order on which to sort.  Must also define sortField.  Overridden by defining sort.
             */
            sortOrder: {
                type: String,
                value: ''
            },

            /**
             * The number of the current page of search results.
             */
            page: {
                type: Number,
                value: 1,
                notify: true
            },

            /**
             * The size of each page of search results.
             */
            pageSize: {
                type: Number,
                value: 25,
                notify: true,
                observer: '_resetPage'
            },

            /**
             * The number of pages of search results.
             */
            pageCount: {
                type: Number,
                value: 1,
                notify: true
            },

            /**
             * An elasticjs filter object or array of elasticjs filter objects.  This property must be defined for searches using the query property.
             */
            filters: {
                type: Array,
                notify: true,
                observer: '_resetPage'
            },

            /**
             * An elasticjs aggregation filter object or array of elasticjs aggregation filter objects.  This property must be defined for searches using the query property.
             */
            aggregations: {
                type: Array,
                notify: true
            },

            /**
             * An elasticjs highlight object.
             */
            highlight: {
                type: Object
            },

            /**
             * The timeout for the elasticsearch query in milliseconds.
             */
            timeout: {
                type: Number,
                value: 60000
            },

            /**
             * elastic search JSON results available after a successful query.
             */
            results: {
                type: Object,
                notify: true,
                readOnly: true,
                value: null
            },

            resultCount: {
                type: Number,
                readOnly: true,
                notify: true,
                computed: 'resolveResultCount(results)'
            },

            /**
             * either null or an error object that was returned from elastic search server.
             */
            lastError: {
                type: Object,
                value: null,
                notify: true,
                readOnly: true
            },

            /**
             *  indicate that search is in progress.
             */
            loading: {
                type: Boolean,
                value: false,
                notify: true,
                readOnly: true
            },

            activeFilter: {
                type: Object
            }
        },

        observers: [
            'basicSearch(body, index, client)',
            'search(client, elasticTypes, index, query, filters, aggregations, page, sort, sortOrder, sortField)'
        ],

        /**
         * Reset page to 1.
         */
        _resetPage: function() {
            this.page = 1;
        },

        /**
         * Performs a server request via the elasticsearch client; invoked whenevery this.query is changed.
         *
         * @return {ElasticSearchResults}
         */
        basicSearch: function() {
            if(this.loading || !this.body) {
                return;
            }

            var me = this;

            // Set 'last-error' and 'results' before 'loading' because we want other components to update their error and results but may not do so if 'loading' is true.
            this._setLastError(null);
            this._setResults(null);
            this._setLoading(true);
            this.client.search({
                requestTimeout: this.timeout,
                index: this.index,
                type: this.elasticTypes,
                body: this.body
            })
            .then(function(results) {
                me._setLoading(false);
                me._setResults(results);
            })
            .catch(function(err) {
                me._setLoading(false);
                me._setLastError(err);
            });
        },

        search: function() {
            if(this.loading) {
              return;
            }

            var me = this;

            // Set 'last-error' and 'results' before 'loading' because we want other components to update their error and results but may not do so if 'loading' is true.
            this._setLastError(null);
            this._setResults(null);
            this._setLoading(true);
            this.client.search({
                requestTimeout: this.timeout,
                index: this.index,
                type: this.elasticTypes,
                size: this.pageSize,
                from: this.pageSize * (this.page - 1),
                body: this.buildRequest()
            })
            .then(function(results) {
                me._setLoading(false);
                me._setResults(results);
            })
            .catch(function(err) {
                me._setLoading(false);
                me._setLastError(err);
            });
        },

        /**
         * Builds an ejs.Request() object based on various inputs.
         *
         * @return {ElasticSearchRequest}
         */
        buildRequest: function() {
            var me = this;
            var request = ejs.Request();

            if (this.query) {
                request.query(this.query);
            } else {
                request.query(ejs.MatchAllQuery());
            }

            var filterArray = (this.filters ? ((this.filters.constructor === Array) ? this.filters : [this.filters]) : []);
            if(filterArray.length) {
                this.activeFilter = this.buildFilter(filterArray);
                request.filter(this.activeFilter);
            }

            if(this.sort && !_.isEmpty(this.sort)) {
                request.sort(this.sort);
            } else if(this.sortField && this.sortOrder) {
                request.sort(ejs.Sort(this.sortField).order(this.sortOrder));
            }

            var aggregationArray = (this.aggregations ? ((this.aggregations.constructor === Array) ? this.aggregations : [this.aggregations]) : []);
            _.each(aggregationArray, function(aggregation) {
                request.agg(me.applyAggregationFilter(aggregation));
            });

            if(this.highlight) {
                request.highlight(this.highlight);
            }

            // TODO: add logic to build entire request from properties.
            // see: https://github.com/YousefED/ElasticUI/src/controllers/IndexController.ts
            // for general idea
            return request;
        },

        resolveResultCount: function(results) {
            if(results && results.hits && results.hits.total !== undefined) {
                return results.hits.total;
            } else if(results && results.hits && results.hits.hits) {
                return results.hits.hits;
            } else {
                return 0;
            }
        },

        applyAggregationFilter: function(agg) {
            var aggName = Object.keys(agg.toJSON())[0];

            //apply all filters except any matching this agg name
            var filterArray = (this.filters ? ((this.filters.constructor === Array) ? this.filters : [this.filters]) : []);
            var filter = this.buildFilter(filterArray, aggName);
            var filteredAgg = ejs.FilterAggregation(aggName).filter(filter).agg(agg);
            return filteredAgg;
        },

        buildFilter: function(filters, excludeName) {
            if(!excludeName) {
                return ejs.AndFilter(filters);
            }

            var remainingFilters = [];
            _.each(filters, function(filter) {
                if(!filter.name() || filter.name() !== excludeName) {
                    remainingFilters.push(filter);
                }
            });
            return ejs.AndFilter(remainingFilters);
        }
    });
</script>
